<?php namespace ProcessWire;

/**
 *
 * Hanna Code Dialog
 *
 * @author Robin Sallis
 *
 * @credits Teppo Koivula: this module utilises code from HannaCodeHelper
 *
 * ProcessWire 3.x
 * Copyright (C) 2011 by Ryan Cramer
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * http://www.processwire.com
 * http://www.ryancramer.com
 *
 */

class HannaCodeDialog extends WireData implements Module, ConfigurableModule {

	/**
	 * Module information
	 */
	public static function getModuleInfo() {
		return array(
			'title' => 'Hanna Code Dialog',
			'version' => '0.2.5',
			'summary' => 'Enhances the use of Hanna tags in CKEditor fields, including the dialog-based editing of Hanna tags.',
			'author' => 'Robin Sallis',
			'icon' => 'clone',
			'autoload' => 'template=admin',
			'singular' => true,
			'requires' => 'ProcessWire>=3.0.0, TextformatterHannaCode',
		);
	}

	/**
	 * Array of Hanna tags that have no attributes
	 */
	protected $tags_no_attributes = array();

	/**
	 * Ready
	 */
	public function ready() {
		$this->addHookBefore('InputfieldForm::render', $this, 'addCheatSheet');
		$this->addHookAfter('ProcessPageEdit::execute', $this, 'pageEditMods');
	}

	/**
	 * Add cheatsheet info to Hanna Code edit
	 *
	 * @param HookEvent $event
	 */
	public function addCheatSheet(HookEvent $event) {
		/* @var InputfieldForm $form */
		$form = $event->object;
		if($form->id !== 'HannaCodeEdit') return;
		$hc_attr = $form->getChildByName('hc_attr');

		$f = $this->wire('modules')->get('InputfieldMarkup');
		$f->name = 'hcd_info';
		$f->label = $this->_('Attributes cheatsheet for HannaCodeDialog');
		$f->value = <<<EOT
<style>
.hcd-cheatsheet { padding:15px 0; }
.hcd-cheatsheet p { margin:10px 0; }
.hcd-cheatsheet h3 { font-size:18px; color:#686868; margin:20px 0 10px; }
.hcd-cheatsheet .mono { font-family:monospace; font-size:15px; background:#ececec; display:inline-block; padding:0 5px; border-radius:3px; margin:0 3px; color:#000; }
.hcd-cheatsheet .mono-block { padding:5px 10px; margin:0; display:block; }
</style>
<div class='hcd-cheatsheet'>

	<p>Use a double underscore to add <span class='mono'>type</span>, <span class='mono'>options</span>, <span class='mono'>description</span> or <span class='mono'>notes</span> settings for an attribute.</p>
	
	<p><strong>For an attributed named 'vegetables'...</strong></p>
	
	<h3>Inputfield type</h3>
	<p class='mono mono-block'>vegetables__type=asmselect</p>
	<p>The default type for text attributes is <span class='mono'>text</span>. The default type for attributes with options specified is <span class='mono'>select</span>.</p>
	<p>Inputfield types are case insensitive. Supported types are <span class='mono'>text</span> <span class='mono'>textarea</span> <span class='mono'>select</span> <span class='mono'>radios</span> <span class='mono'>selectmultiple</span> <span class='mono'>asmselect</span> <span class='mono'>checkboxes</span> <span class='mono'>checkbox</span></p>
	<p>The <span class='mono'>checkbox</span> type allows for an integer value of 1 or 0.</p>
	
	<h3>Options: static</h3>
	<p class='mono mono-block'>vegetables__options=Spinach|Pumpkin|Celery|Tomato|Brussels Sprout|Potato</p>
	<p>Use the pipe character as a delimiter between options.</p>
	
	<h3>Options: dynamically generated by another Hanna tag</h3>
	<p class='mono mono-block'>vegetables__options=[[_generate_vegetable_options]]</p>
	<p>You can use one Hanna tag to generate options for another Hanna tag. The tag that generates the options should <strong>echo</strong> a string of options delimited by pipe characters (i.e. the same format as a static options string).</p>
	<p>You will probably want to name the Hanna tag that generates the options so that it starts with an underscore, to avoid it appearing as an insertable tag in the HannaCodeDialog dropdown menu.</p>
	
	<h3>Inputfield description</h3>
	<p class='mono mono-block'>vegetables__description=Please select vegetables for your soup.</p>
	
	<h3>Inputfield notes</h3>
	<p class='mono mono-block'>vegetables__notes=Pumpkin and celery is a delicious combination.</p>

</div>
EOT;
		$f->icon = 'question-circle';
		$f->collapsed = Inputfield::collapsedYes;
		$form->insertAfter($f, $hc_attr);
	}

	/**
	 * Mods to ProcessPageEdit
	 *
	 * @param HookEvent $event
	 */
	public function pageEditMods(HookEvent $event) {
		$config = $this->wire('config');

		// Return if ProcessPageEdit is being loaded via AJAX (image field)
		if($config->ajax) return;

		$edited_page = $event->object->getPage();

		// Render Hanna tag form if tag variable in $input
		$tag = $this->wire('input')->get->textarea('tag');
		if($tag) {
			$event->replace = true; // Don't render normal page edit form
			$current_attributes = $this->getAttributes($tag);
			if(!isset($current_attributes['name'])) $current_attributes['name'] = trim($tag);
			$vars = array( 'current_attributes' => $current_attributes, 'hanna_tags' => $this->getHannaTags(), 'edited_page' => $edited_page );
			$options = array('defaultPath' => $config->paths->{$this});
			$event->return = $this->wire('files')->render('iframe_form', $vars, $options);
		}

		// Add JS
		$js = '';
		$js_config = $config->js();
		foreach($js_config as $key => $value) {
			// Check for extraPlugins key to identify CKEditor within Profields Table
			if(strpos($key, 'InputfieldCKEditor_') !== false || isset($value['extraPlugins'])) {
				$js .= "config.$key.extraPlugins += ',hannadropdown,hannadialog';";
			}
		}
		// Return if no CKEditor fields with TextformatterHannaCode found
		if(!$js) return;

		// Add CKEditor plugins and init JS variables
		$js .= '';
		$plugins_path = $config->urls->{$this} . 'plugins';
		$js = "
		var hcd_config = config.HannaCodeDialog;
		var tag = null;
		CKEDITOR.plugins.addExternal('hannadropdown', '{$plugins_path}/hannadropdown/');
		CKEDITOR.plugins.addExternal('hannadialog', '{$plugins_path}/hannadialog/');
		" . $js;
		$event->return = "<script>$js</script>" . $event->return;

		// To config JS
		$settings = array();
		$data = $this->wire('modules')->getModuleConfigData('TextformatterHannaCode');
		$settings['iframe_path'] = "{$this->wire('page')->url}?id={$edited_page->id}&modal=1";
		$settings['open_tag'] = !empty($data['openTag']) ? $data['openTag'] : \TextformatterHannaCode::DEFAULT_OPEN_TAG;
		$settings['close_tag'] = !empty($data['closeTag']) ? $data['closeTag'] : \TextformatterHannaCode::DEFAULT_CLOSE_TAG;
		$settings['hanna_tags'] = $this->getDropdownTags($edited_page);
		$settings['tags_no_attributes'] = $this->tags_no_attributes;
		$settings['widget_colour'] = $this->widget_colour ?: '#d3eaf2';
		$settings['dialog_width'] = $this->dialog_width ?: 360;
		$settings['dialog_height'] = $this->dialog_height ?: 420;
		$settings['dropdown_title'] = $this->_('Insert Hanna tag');
		$settings['dialog_title'] = $this->_('Hanna Code Dialog');
		$config->js($this->className, $settings);

		// Add CSS
		$info = $this->getModuleInfo();
		$version = $info['version'];
		$config->styles->add($config->urls->{$this} . "{$this}.css?v={$version}");
	}

	/**
	 * Get Hanna Code tags from database
	 *
	 * @param bool $name_only
	 * @param bool $filter_tags
	 * @return array
	 */
	public function getHannaTags($name_only = false, $filter_tags = false) {
		// Instantiate TextformatterHannaCode
		$hanna = $this->wire('modules')->get('TextformatterHannaCode');
		// Fetch Hanna Code tags from database
		$tags = array();
		$tags_no_attributes = array();

		$sql = "SELECT name, code FROM hanna_code ORDER BY name";
		$query = $this->wire('database')->prepare($sql);
		$query->execute();
		while($row = $query->fetch(\PDO::FETCH_NUM)) {
			list($name, $code) = $row;
			// If this tag has no attributes then add it to $tags_no_attributes
			if(strpos($code, 'hc_attr*/') === false) $tags_no_attributes[] = $name;
			if($name_only) {
				if($filter_tags) {
					$exclude_prefix = $this->exclude_prefix ?: '_';
					if((is_array($this->exclude_selection) && in_array($name, $this->exclude_selection)) || strpos($name, $exclude_prefix) === 0) continue;
				}
				$tags[] = $name;
			} else {
				$attrs = array();
				foreach($hanna->extractDefaultCodeAttrs($code) as $attr_name => $attr_value) {
					$attrs[$attr_name] = $attr_value;
				}
				$tags[$name] = $attrs;
			}
		}
		$this->tags_no_attributes = $tags_no_attributes;
		return $tags;
	}

	/**
	 * Get Hanna Code tags for toolbar dropdown
	 *
	 * @param Page $page The page being edited
	 * @return array Array of tag names
	 *
	 */
	public function ___getDropdownTags($page) {
		return $this->getHannaTags(true, true);
	}

	/**
	 * Build dialog form
	 *
	 * @param string $tag_name
	 * @param Page $edited_page
	 * @param array $current_attributes
	 * @param array $default_attributes
	 * @return InputfieldForm $form
	 */
	public function ___buildForm($tag_name, $edited_page, $current_attributes, $default_attributes) {
		/* @var InputfieldForm $form */
		$form = $this->modules->get('InputfieldForm');
		$form->attr('id+name', 'hanna-form');
		$form->attr('data-name', $tag_name);
		return $form;
	}

	/**
	 * Prepare options for use in dialog inputfield
	 *
	 * @param string $options_string String of options delimited with a pipe character
	 * @param string $attribute_name The name of the attribute the options are for
	 * @param string $tag_name The name of the Hanna tag
	 * @param object $page The page being edited
	 * @return array A regular array of option values, or an associative array $value => $label
	 *
	 */
	public function ___prepareOptions($options_string, $attribute_name, $tag_name, $page) {
		$options = explode('|', $options_string);
		return $options;
	}

	/**
	 * Find an return an array of all attributes in string $expression
	 * Lifted from TextformatterHannaCode
	 *
	 * @param string $expression
	 * @return array
	 *
	 */
	protected function getAttributes($expression) {

		$attrs = array();

		$regx =
			'!(?:^|\b)' .		    // beginning or boundary
			'([-_a-z0-9]+)' .	    // 1. attribute name
			'\s*=\s*' . 		    // Equals
			'(' .				    // 2. attribute value, possibly with quotes
			'(["\']|&quot;)' .	    // 3. open quote
			'.*?' . 		        // attribute value unquoted
			'\3' .			        // close quote
			'|' .				    // OR
			'[^\'",\s]*' .		    // unquoted value...
			'),?' . 			    // optional comma, per PW selector style
			'!i';

		if(!preg_match_all($regx, $expression, $matches)) {
			return $attrs;
		}

		foreach($matches[1] as $key => $name) {
			$attrs[$name] = trim($matches[2][$key], "'\"");
		}

		if(empty($attrs['name'])) {
			// allow for optional [[name_here attrs]] expression
			// where the 'name' isn't specifically called out as an attribute
			// but is the first symbol in the expression
			if(preg_match('!^([-_a-z0-9]+)([\s,]|$)!i', $expression, $matches)) {
				$attrs['name'] = $matches[1];
			}
		}

		return $attrs;
	}

	/**
	 * Config inputfields
	 *
	 * @param InputfieldWrapper $inputfields
	 */
	public function getModuleConfigInputfields(InputfieldWrapper $inputfields) {
		$modules = $this->wire('modules');

		/* @var InputfieldText $f */
		$f = $modules->InputfieldText;
		$f_name = 'exclude_prefix';
		$f->name = $f_name;
		$f->label = $this->_('Exclude prefix');
		$f->description = $this->_('Tags that have this prefix will not appear in the toolbar dropdown.');
		$f->columnWidth = 50;
		$f->value = $this->$f_name ?: '_';
		$inputfields->add($f);

		/* @var InputfieldAsmSelect $f */
		$f = $modules->InputfieldAsmSelect;
		$f_name = 'exclude_selection';
		$f->name = $f_name;
		$f->label = $this->_('Exclude Hanna tags');
		$f->description = $this->_('Tags that are selected here will not appear in the toolbar dropdown.');
		$f->columnWidth = 50;
		foreach($this->getHannaTags(true) as $select_option) {
			$f->addOption($select_option);
		}
		$f->value = $this->$f_name;
		$inputfields->add($f);

		/* @var InputfieldText $f */
		$f = $modules->InputfieldText;
		$f_name = 'widget_colour';
		$f->name = $f_name;
		$f->label = $this->_('Background colour of tag widgets');
		$f->columnWidth = 33;
		$f->value = $this->$f_name ?: '#d3eaf2';
		$inputfields->add($f);

		/* @var InputfieldInteger $f */
		$f = $modules->InputfieldInteger;
		$f_name = 'dialog_width';
		$f->name = $f_name;
		$f->label = $this->_('Dialog width');
		$f->columnWidth = 33;
		$f->inputType = 'number';
		$f->min = 0;
		$f->value = $this->$f_name ?: 360;
		$inputfields->add($f);

		/* @var InputfieldInteger $f */
		$f = $modules->InputfieldInteger;
		$f_name = 'dialog_height';
		$f->name = $f_name;
		$f->label = $this->_('Dialog height');
		$f->columnWidth = 34;
		$f->inputType = 'number';
		$f->min = 0;
		$f->value = $this->$f_name ?: 420;
		$inputfields->add($f);
	}

}
